#### NOTE5
- 추상클래스: 인터페이스와 클래스 사이
    - 구현은 갖되, 인스턴스는 갖지 못함
    - 클래스의 접근성 사용
    - 다른 추상 클래스 상속 가능

    - 추상메소드 생성을 위해선 abstract 클래스로 만들어야 함
    - 추상메소드 재정의((== 구현))

- 추상메소드; 추상클래스의 인터페이스 역할을 위한 장치
    - 파생클래스에서 구현 필수
    - 접근성 : public, protected, internal, protected internal

- 프로퍼티
    - public 필드의 유혹,,
        - 할당연산자 '='를 이용한 필드 액세스의 유혹 (데이터의 오염 가능성이 높아짐)
        - Get / Set 메소드를 이용해 필드 은닉 (번거롭고 귀찮음)
    → 프로퍼티가 은닉성과 편의성 해결
    
    - 예상치 못한 값이 들어갈 수 있음(데이터 오염 가능성)
     -> get; / set; 메소드 -> △ public 메소드가 두 개씩 생성됨
     => 하나의 프로퍼티로  Get / Set 두 가지 기능 할 수 있음

    - 자동구현 프로퍼티; 단순히 필드를 읽고 쓰기만 하는 경우
    - 들어오는 데이터를 필터링할 때는 private 멤버변수와 public 프로퍼티를 둘다 사용
    - 필터링이 필요없으면 멤버변수 없이 프로퍼티로 대체
    - 선언과 동시에 초기화

- 인터페이스 ; 프로퍼티 선언과 클래스의 자동구현 프로퍼티 선언과 동일
    - 상속하는 클래스에서 프로퍼티 구현

- 배열 
    - 버퍼에서 배열 사용, 많이 안 씀
    - char[] oldString = new char[5];     // 문자열 길이를 지정해야 함((조선시대 방법 - C에서만 사용))
    - string curString = "";              // 문자열 길이 제한 없음
- 컬렉션; 같은 성격의 데이터 모음을 담는 자료 구조
    - 배열(Sysytem.Array 클래스)도 컬렉션 자료 구조
    - .NET 프레임워크 컬렉션 클래스
        - ArrayList - .Add(), .Insert(x, val), .Remove(val), .RemoveAt(x), .Sort(), .Reverse()
        - Queue; FIFO(CPU의 작업, 프린터의 여러 문서 출력, 스트리밍 서비스에서 콘텐츠 버퍼링)
            - 입력은 오직 뒤에서 / 출력은 앞에서만  - Enqueue(), Dequeue() 메소드
        - Stack; FILO, LIFO 컬렉션
            - 입력 Push() / 출력 Pop()
        - Hashtable; 키와 값의 쌍으로 이루어진 데이터를 다룰 때 사용 - 탐색속도 빠르고 편리
- 인덱서; 인덱스를 이용해 객체 내 데이터에 접근하게 하는 프로퍼티