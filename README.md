# basic-CSharp-2023
IoT 개발자 과정 C# 학습 리포지토리

## 1일차

-  C# 기본
    - .NET Framework / .NET 5.0 이후
    - Visual Studio상 C# 구성
    - 기본 문법

#### 들어가기 앞서
- 인터프리터(통역) 언어
    - 인터프리터 언어 종류: 자바스크립트, HTML, 액션스크립트, SQL, python, ruby 등..
    - 컴파일이 없기 때문에, 별도의 컴파일시간이 없음
    - 인터프리트 단계와 실행 단계 분리 X
    - 인터프리터는 한 줄씩 바이트코드로 변환 후 즉시 실행
    - 코드 실행시마다 인터프리트 과정 반복 수행 => 실행속도가 느림
- 컴파일러 언어
    - 컴파일 언어 종류: C#, C++, JAVA, C 등 ..
    - 코드 실행 전, 컴파일 타임에 소스 코드 전체를 한번에 기계어로 변환 후 실행파일 만듦 + 실행
    - 실행이 인터프리터보다 빠름
    - 크기가 큰 소스코드의 경우 컴파일 시간이 오래 걸릴 수 있지만 인터프리터 언어의 경우 바로 실행이 가능
    - 자바는 클래스까지만 만들어지고 실행파일이 안 만들어지기도

- .NET Framework
    - 윈도우 OS의 기능을 쉽게 다루는 클래스 라이브러리
    - 웹 서비스 쉽게 개발하는 도구
    - C#은 .NET Framework에 최적화된 언어
    - JAVA는 어느 OS에서도 작동 / .NET Framework는 윈도우에서만 사용 가능
    - JAVA는 오픈소스 / .NET Framework는 클로즈, 유료 ---> 과거 사람들이 자바로 간 이유
    - .NET 5.x 부터는 여러 운영체제 프로그램 개발이 가능
        - .NET Core, Xamarin 등이 하나로 합쳐진 버전

#### NOTE1
- using : C# 키워드
- namespace : 성격, 하는 일이 비슷한 형식을 하나의 이름으로 그룹화
- 클래스
    - C# 프로그램을 구성하는 기본 단위  
    - 데이터와 데이터 처리 기능(메소드)
    - class class_name { }

- 참조형식
    - 문자열 형식
    - 오브젝트 형식
- 값형식
    - 숫자 형식
    - 논리형식
- Object 형식; 어떤 물건이든 다룰 수 있는 데이터 형식
    - 상속 효과
    - 참조형식 -> 힙영역에 할당
    - Object 형식은 모든 데이터 형식을 담을 수 있음
- boxing / unboxing
- 형변환
    - 오버플로우 주의
    - 문자열로 적힌 숫자를 숫자로 형변환 할 때 숫자가 아닌 것이 있다면 예외발생
    - TryParse는 예외가 발생하면 값은 0으로 대체 / 예외 없으면 원래 값으로
        - 파싱하면서 예외 상황으로 인한 비정상적인 프로그램 종료 방지
- 상수; 데이터를 절대 바꿀 수 없는 메모리 공간
- enum; 같은 특성을 가진 것을 열거
- Nullable 형식; 어떤 값도 가지지 않는 변수가 필요할 때 (C# 6.0부터 등장)
    - 값형식 byte, short, int, long, float, double, char 등은 null을 할당X
    - null을 할당할 수 있도록 만드는 방식 : type?
    - ex> int? a = null;
- var 형식; 약한 형식 검사 방법(C# 4.0부터 등장)
    - 선언과 동시 초기화 필수
    - 지역 변수로만 사용
    - 로컬에서만 적용
    - C#은 strict(강력한 형식) 언어
        - 의도치 않은 형식의 데이터를 읽거나 할당하는 일 차단
    - 약한 형식 검사
        - 코드 작성 단계에서 편리
        - 컴파일러에서 변수에 담긴 데이터에 따라 자동으로 형식 지정
- CTS(공용 형식 시스템); .NET Framework의 형식 체계의 표준 -> .NET 언어들 간의 호환
- Null 조건부 연산자; 객체의 멤버에 접근하기 전에 널인지 검사
    - 객체 ?. 반환멤버
    - 객체 ? [배열(컬렉션)의 인덱스]


## 2일차
- C# 기본
    - 기본 문법 (변수, 메소드, 연산자, 제어)

- Win App
    - WinForms vs WPF 개요
    - WinForms 기초

#### NOTE2
- 비트연산자 , 쉬프트
- Null 병합 연산자
- 분기문
- 데이터타입 비교 switch문(C# 7.0부터 - .NET Framework 4.7 / 4.8)
- foreach
- static(정적); 실행되면 메모리에 올라가서 언제든 접근 가능
    - 객체를 만들 필요 없음
    - static 안 쓰면 new Calc() 사용해 객체 생성 -> 힙에 객체를 올려보내야 함
- 메소드; 일련의 코드를 하나의 이름 아래 묶은 것
    - 메소드 선언 형식
    - 메소드 호출
- 매개변수
    - Main 메소드와 같은 레벨에 있는 메소드들은 전부 static이 되어야 함
    - 출력전용 매개 변수; 두 가지 이상의 결과가 필요한 메소드
    - 메소드 결과를 참조로 반환
    - ref 키워드 / out 키워드
    - 참조에 의한 매개변수 전달; 매개 변수로 직접 원본 변수의 값을 바꾸는 방법
    - Call by value / Call by reference; 주소 전달(포인터과 비슷한 역할)
    - 가변길이 매개변수


## 3일차
- C# 기본
    - 클래스

- Win App
    - WinForms 컨트롤
    - 리스트뷰, 데이터그리드 추가학습 요

3일차 윈폼 학습 결과

<img src="https://raw.githubusercontent.com/limchaeyeon8/basic-CSharp-2023/main/d3/d3WinApp/wf03_property/wifm1.png" width="700">
    
#### NOTE3
- 클래스
- 생성자; 클래스와 같은 이름 / 반환형식 없음
    - 기본 생성자 
    - 사용자 지정 생성자; 객체 생성시 필드 초기화
- 파괴자(종료자); 매개변수x, 한정자 사용x, 오버로딩 불가능, 직접 호출 x
    - CLR의 가비지 컬렉터가 객체 소멸 시점 판단해서 종료자 호출하기 때문에 따로 안 써도 O
- static 정적 필드 / 메소드
    - static은 메소드나 필드가 클래스 자체에 소속되도록 지정하는 한정자
    - 인스턴스(new) 만들지 않고 클래스의 이름을 통해 필드에 직접 접근
    - 프로그램 전체에 공유하는 변수에 사용
-  정적필드 / 정적 메소드
    - 정적 메소드; 클래스 자체에 소속됨
        - 클래스 인스턴스 생성 없이도 호출 가능
        - 인스턴스 생성이 필요한 메소드 - 인스턴스 메소드; 객체 내부 데이터 이용
- 얕은 복사 / 깊은 복사 
- this; 객체 내부에서 자신의 필드나 메소드에 접근할 때 사용
- 객체지향 4가지 특성 - 추상화, 상속, 다형성, 캡슐화
    - 은닉성(캡슐화); 감추고 싶은 것은 감추고 보여주고 싶은 것만 보여줌
    - 접근 한정자
        - private       클래스 내부 접근 only / 파생(자식)클래스에서 접근X
        - public        클래스 내외부 접근O
        - protected     클래스 외부X / 파생(자식)클래스에서 접근O
        - internal      같은 어셈블리에 있는 코드에서만 public으로 접근 / 다른 어셈블리에 있는 코드에서는 private과 같은수준의 접근성
        - protected internal    
        - private protected     
- 파생(자식)클래스; 아무 멤버를 선언하지 않아도 기반 클래스의 모든 것을 물려받아 갖게 됨(단, private으로 선언된 멤버는 예외)
    - 상속해서 사용할거면 부모클래스의 private을 protected나 public으로 변경해야 함


- 컨트롤 학습 - 폰트 및 글자사이즈 변경
- 트랙바 / 진행바
- 모달 / 모달리스 / 메시지창
    - Modal창은 자식창이 떠있는 동안 부모창을 못 건들이게 함
    - 모달은 부모창 닫으려 해도 안 닫힘
    - 모달리스는 부모창 닫으면 같이 닫힘
- 트리뷰 / 리스트뷰
    - .Expand() / .collapse()

## 4일차
- C# 기본
    - 클래스 상속 계속
    - 인터페이스 *
- Win App
    - WinForms 컨트롤 마무리
    - WinForms 예제 실습

#### NOTE4
- 기반/파생클래스 사이의 형식 변환
- is / as   - 클래스에서만 됨
- 다형성; 객체가 여러 형태를 가질 수 있음을 의미
    - 하위 형식 다형성
- 오버라이딩 조건
    - 대상 메소드를 virtual 키워드로 선언
    - private 선언 메소드는 오버라이딩 불가
    - 재정의 => Override 키워드
- 분할 클래스(partial 클래스); 클래스 구현이 길어질 경우 여러 파일에 나눠 구현
- 확장 메소드(static - 정적); 기존 클래스의 기능 확장하는 기법
- * 인터페이스
    - 클래스의 다중 상속이 갖는 문제
        - 죽음의 다이어몬드 문제(c++) => 모호성
        - 업캐스팅; 자식 클래스의 객체가 부모 클래스 타입으로 형변환 되는 것
    - 인터페이스의 다중 상속 - 단순한 외형만 상속함으로 내부 구현은 상속자에게 맡김
                            (c#에서 다중상속 없애고 클래스 하나만 상속 => 새로운 문제 --해결--> 인터페이스)

    - interface와 class차이; interface는 구현부(내용) 없음 - 서론만 존재(ex> Method void Name (매개 변수 목록);)
    - 인터페이스 특징
        - 가능한 멤버 : 메소드, 이벤트, 인덱서, 프로퍼티
        - 모두 public으로 선언
        - 인스턴스 생성 불가(참조는 가능)
        - 인터페이스를 상속 받은 클래스의 인스턴스 생성 가능
        - WriteLog()

    - 인터페이스 구현       (인터페이스) 구현 != (클래스) 상속
    - new 클래스 (O) / new 인터페이스 (X)
    - void WriteLog(string format, params object[] args);     // 다중 파라미터를 받을 수 있는 형태(args; arguments)
    - WriteLog(string format, params object[] args)
